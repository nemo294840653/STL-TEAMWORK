# STL基本用法简介

组长：郑值

组员：王新

## STL简介

STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++ 程序库。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。

从逻辑层次来看，在STL中体现了泛型化程序设计的思想（generic programming），引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代子（iterator）等。

从实现层次看，整个STL是以一种类型参数化（type parameterized）的方式实现的，这种方式基于一个在早先C++ 标准中没有出现的语言特性–模板（template）。

STL提供六大组件，分别是容器，算法，迭代器，仿函数，配接器以及配置器。下面主要介绍容器，算法以及迭代器

## 容器

**容器（Container）是一种数据结构，如 list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；容器可以分为三个类别：序列容器、关联容器和容器适配器。下面主要介绍前两种**

### 序列容器

序列容器可以维护你指定的插入元素的顺序，常见的序列容器例如vector, list, deque, string.

#### vector

- 数据结构：是一种动态数组，在内存中具有连续的存储空间


- 特点：可以**随机存取**元素。在数组尾部添加或删除元素非常快速，但是在中部或头部插入或删除元素比较耗时。

- 常见函数

  | 函数名       | 功能                                       |
  | --------- | ---------------------------------------- |
  | push_back | 在数组的最后添加一个数据, 示例： `c.push_back(5);`      |
  | pop_back  | 去掉数组的最后一个数据, 示例：`c.pop_back();`          |
  | at        | 得到编号位置的数据， 示例： `int d = c.at(0);`        |
  | begin     | 得到数组头的指针, 示例： `vector<int>::iterator it = c.begin();` |
  | end       | 得到数组的最后一个单元+1的指针, 示例： `vector<int>::iterator it = c.end();` |
  | front     | 得到数组头的引用, 示例： `int first = c.front();`   |
  | back      | 得到数组的最后一个单元的引用, 示例： `int last = c.back();` |
  | max_size  | 得到vector最大可以是多大                          |
  | capacity  | 当前vector分配的大小                            |
  | size      | 当前使用数据的大小                                |
  | resize    | 改变当前使用数据的大小，如果它比当前使用的大，则填充默认值            |
  | reserve   | 改变当前vecotr所分配空间的大小                       |
  | erase     | 删除指针指向的数据项                               |
  | clear     | 清空当前的vector                              |
  | rbegin    | 将vector反转后的开始指针返回(其实就是原来的end-1)          |
  | rend      | 将vector反转后的结束指针返回(其实就是原来的begin-1)        |
  | empty     | 判断vector是否为空                             |
  | swap      | 与另一个vector交换数据                           |

#### deque

- 数据结构：在头尾两端分别可以做元素的插入和删除的多个连续线性空间，并且在一个映射结构中保存对这些块及其顺序的跟踪

- 特点：可以**随机存取**。数组尾部或头部添加或删除元素非常快速，但在中部插入或删除元素比较费时；可以在两端进行push 、pop ；相对于verctor 占用更多的内存。

- 常见函数

  | 函数名       | 功能               |
  | --------- | ---------------- |
  | assign    | 设置双向队列的值         |
  | at        | 返回指定的元素          |
  | back      | 返回最后一个元素         |
  | begin     | 返回指向第一个元素的迭代器    |
  | clear     | 删除所有元素           |
  | empty     | 返回真如果双向队列为空      |
  | end       | 返回指向尾部的迭代器       |
  | erase     | 删除一个元素           |
  | max_size  | 返回双向队列能容纳的最大元素个数 |
  | pop_back  | 删除尾部的元素          |
  | pop_front | 删除头部的元素          |
  | swap      | 和另一个双向队列交换元素     |
  | size      | 返回双向队列中元素的个数     |
  | resize    | 改变双向队列的大小        |

#### list

- 数据结构：双向链表，内存空间可以不连续，通过指针来进行数据的访问

- 特点：与前面两种容器类有一个明显的区别就是：它**不支持随机访问**只能**顺序访问**，但是在任何位置插入或删除动作都非常迅速。

- 常见函数

  | 函数名             | 说明                                    |
  | --------------- | ------------------------------------- |
  | assign()        | 给list赋值                               |
  | back()          | 返回最后一个元素                              |
  | begin()         | 返回指向第一个元素的迭代器                         |
  | clear()         | 删除所有元素                                |
  | empty()         | 如果list是空的则返回true                      |
  | end()           | 返回末尾的迭代器                              |
  | erase()         | 删除一个元素                                |
  | front()         | 返回第一个元素                               |
  | get_allocator() | 返回list的配置器                            |
  | insert()        | 插入一个元素到list中                          |
  | max_size()      | 返回list能容纳的最大元素数量                      |
  | merge()         | 合并两个list                              |
  | pop_back()      | 删除最后一个元素                              |
  | pop_front()     | 删除第一个元素                               |
  | push_back()     | 在list的末尾添加一个元素                        |
  | push_front()    | 在list的头部添加一个元素                        |
  | rbegin()        | 返回指向第一个元素的逆向迭代器                       |
  | remove()        | 从list删除元素                             |
  | remove_if()     | 按指定条件删除元素                             |
  | rend()          | 指向list末尾的逆向迭代器                        |
  | resize()        | 改变list的大小                             |
  | reverse()       | 把list的元素倒转                            |
  | size()          | 返回list中的元素个数                          |
  | sort()          | 给list排序                               |
  | splice()        | 合并两个list,源list的内容部分或全部元素删除，拼插入到目的list |
  | swap()          | 交换两个list                              |
  | unique()        | 删除list中重复的元素                          |

- 小结

**在实际使用时，如何选择这三个容器中哪一个，应根据需要而定，一般应遵循下面的原则：**

- 如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector
- 如果需要大量的插入和删除，而不关心随即存取，则应使用list
- 如果需要随即存取，而且关心两端数据的插入和删除，则应使用deque

### 关联容器

关联容器类似于关联式数据库，每个元素都有一个键值与一个实值。当元素被插入到关联式容器中式，容器内部结构便按照其键值大小将元素插入到合适的位置。关联容器与序列容器不同，没有所谓的头尾，只有最大值与最小值，因此不会有上面的push_back(),pop_back()等操作

标准的STL关联容器分为set以及map，这些容器的底层机制均以红黑树完成。

#### map

- 数据结构：红黑树

- 特点：用唯一的关键字来映射相应的值，即具有key-value功能；具有数据自动排序的功能，所以在map内部所有的数据都是有序的；map的插入和删除效率比其他序列的容器高

- 常见操作

  | 函数名              | 说明                                       |
  | ---------------- | ---------------------------------------- |
  | count            | count(k)返回k在m中出现的次数，在map中只是返回0、1         |
  | find             | find(k) :如果k在m中的键值存在则返回相应的迭代器，否则返回超出来末端迭代器 |
  | erase(k)         | 删除m中键为k的元素。返回值为被删除元素的个数，对于map容器而言，其值必然是0或1。 |
  | erase(p          | 从m中删除迭代器p所指向的元素,返回值为void类型。              |
  | erase(b,e)       | 从m中删除一段由一对迭代器范围的元素,返回值为void类型。           |
  | insert (beg,end) | 插入beg、end标记范围内的元素，如果该元素的m.first已经存在则不插入否则插入。返回void类型 |
  | insert(iter,e)   | 如果e.first不在m中，则创建新元素，并以迭代器iter为起点搜索新元素的存储位置，否则返回一个迭代器，指向m中具有的给定键的元素。 |
  | insert(e)        | e是一个用在m上的value_type类型的值，如果e.first不在m中则插入一个值为.second的新元素，否则该键值在m中已经存在则保持不变，该函数返回一个pair新类型，包含一个指向键值为e.first的元素的map迭代器，以及一个bool类型的对象，表示是否插入该元素 |

#### set

- 数据结构：红黑树

- 特点：set元素的实值就是键值；同map一样，插入删除操作时仅仅移动指针即可，不涉及内存的移动和拷贝，所以效率比较高；set中的元素都是唯一的，而且默认情况下会对元素进行升序排列。所以在set中，不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，再插入新元素；不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存取。

- 常见操作

  | 函数名                      | 说明               |
  | ------------------------ | ---------------- |
  | insert                   | 在set中添加元素        |
  | count                    | 返回某个元素在set中出现的次数 |
  | find                     | 在set中查找某个元素      |
  | clear                    | 删除元素             |
  | set_intersection         | 对集合求交集           |
  | set_difference           | 对集合求差            |
  | set_union                | 对集合求并集           |
  | set_symmetric_difference | 对集合求对称差          |

## 迭代器

迭代器提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象。

#### Iterator模式

STL中迭代器按照移动特性与读写方式分为 `input_iterator`, `output_iterator`, `forward_iterator`, `bidirectional_iterator`, `random_access_iterator` 这5种

- input_iterator: 这种迭代器所指对象只允许读取，而不允许改变，是只读的（read only）
- output_iterator: 与上面的相反，只能写（write only）
- forward_iterator: 同时允许读和写，适用于 `replace()` 等算法
- bidirectional_iterator: 可双向移动，即既可以按顺序访问，也可以按逆序访问
- random_access_iterator: 前4种只提供一部分指针运算功能，如前3种只支持 `operator++`, 而第4种还支持 `operator--`, 但这种随机访问迭代器还支持 `p+n`, `p-n`, `p[n]`, `p1-p2`, `p1+p2` 等

尽管各种不同的STL实现细节方面有所不同，还是可以将上面的迭代器想象为一种类继承关系。从这个意义上说，下面的迭代器继承自上面的迭代器。由于这种继承关系，你可以将一个Forward迭代器作为一个output或input迭代器使用。同样，如果一个算法要求是一个bidirectional 迭代器，那么只能使用该种类型和随机访问迭代器。Iterator模式有三个重要的作用：

#### Iterator应用

- 它支持以不同的方式遍历一个聚合.复杂的聚合可用多种方式进行遍历，如二叉树的遍历，可以采用前序、中序或后序遍历。迭代器模式使得改变遍历算法变得很容易: 仅需用一个不同的迭代器的实例代替原先的实例即可，你也可以自己定义迭代器的子类以支持新的遍历，或者可以在遍历中增加一些逻辑，如有条件的遍历等。
- 迭代器简化了聚合的接口. 有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口了，这样就简化了聚合的接口。
- 在同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态，因此你可以同时进行多个遍历。
- 此外，Iterator模式可以为遍历不同的聚合结构（需拥有相同的基类）提供一个统一的接口，即支持多态迭代。

## 算法

在STL标准库中并没有给每个容器添加大量的功能，而是提供了一组算法，这些算法大多独立于特定容器而通用（或称泛型的）：可用于不同类型的容器和不同类型的元素。

所有泛型算法的前两个参数都是一对迭代器first与last，STL算法都作用在由迭代器[first,last)所标示出来的区间上。这个区间的必要条件是必须能够经由累加操作符的反复运用，从first到达last，否则会出现未定义的结果。算法可分为质变算法和非质变算法两种，质变算法会更改区间内的元素内容，而非质变算法不会。质变算法通常分为就地进行（in-place）版，就地改变操作对象，和另地进行（copy）版，将对象内容复制后修改并返回副本。copy版总以_copy作为函数名称尾词。并不是所有质变算法都有copy版。

STL规定用户若想要使用数值算法，必须包含上层numeric头文件，若要使用其他算法，必须包含algorithm头文件。

STL中算法可细分为以下四类：

#### 非可变序列算法

指不直接修改其所操作的容器内容的算法。

| 操作名             | 作用                    |
| --------------- | --------------------- |
| for_each()      | 对序列中的每个元素执行某操作        |
| find()          | 在序列中找出某个值的第一次出现的位置    |
| find_if()       | 在序列中找出符合某谓词的第一个元素     |
| find_end()      | 在序列中找出一子序列的最后一次出现的位置  |
| find_first_of() | 在序列中找出第一次出现指定值集中之值的位置 |
| adjacent_find() | 在序列中找出相邻的一对值          |
| count()         | 在序列中统计某个值出现的次数        |
| count_if()      | 在序列中统计与某谓词匹配的次数       |
| mismatch()      | 找出两个序列相异的第一个元素        |
| equal()         | 两个序列中的对应元素都相同时为真      |
| search()        | 在序列中找出一子序列的第一次出现的位置   |
| search_n()      | 在序列中找出一值的连续n次出现的位置    |


#### 可变序列算法

指可以修改它们所操作的容器内容的算法。

| 操作                 | 作用                   |
| ------------------ | -------------------- |
| copy()             | 从序列的第一个元素起进行复制       |
| copy_backward()    | 从序列的最后一个元素起进行复制      |
| swap()             | 交换两个元素               |
| swap_ranges()      | 交换指定范围的元素            |
| iter_swap()        | 交换由迭代器所指的两个元素        |
| transform()        | 将某操作应用于指定范围的每个元素     |
| replace()          | 用一个给定值替换一些值          |
| replace_if()       | 替换满足谓词的一些元素          |
| replace_copy()     | 复制序列时用一给定值替换元素       |
| replace_copy_if()  | 复制序列时替换满足谓词的元素       |
| fill()             | 用一给定值取代所有元素          |
| fill_n()           | 用一给定值取代前n个元素         |
| generate()         | 用一操作的结果取代所有元素        |
| generate_n()       | 用一操作的结果取代前n个元素       |
| remove()           | 删除具有给定值的元素           |
| remove_if()        | 删除满足谓词的元素            |
| remove_copy()      | 复制序列时删除具有给定值的元素      |
| remove_copy_if()   | 复制序列时删除满足谓词的元素       |
| unique()           | 删除相邻的重复元素            |
| unique_copy()      | 复制序列时删除相邻的重复元素       |
| reverse()          | 反转元素的次序              |
| reverse_copy()     | 复制序列时反转元素的次序         |
| rotate()           | 循环移动元素               |
| rotate_copy()      | 复制序列时循环移动元素          |
| random_shuffle()   | 采用均匀分布来随机移动元素        |
| partition()        | 将满足某谓词的元素都放到前面       |
| stable_partition() | 将满足某谓词的元素都放到前面并维持原顺序 |

#### 排序算法

包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。

| **操作**                     | 作用                        |
| -------------------------- | ------------------------- |
| sort()                     | 以很好的平均效率排序                |
| stable_sort()              | 排序，并维持相同元素的原有顺序           |
| partial_sort()             | 将序列的前一部分排好序               |
| partial_sort_copy()        | 复制的同时将序列的前一部分排好序          |
| nth_element()              | 将第n各元素放到它的正确位置            |
| lower_bound()              | 找到大于等于某值的第一次出现            |
| upper_bound()              | 找到大于某值的第一次出现              |
| equal_range()              | 找到（在不破坏顺序的前提下）可插入给定值的最大范围 |
| binary_search()            | 在有序序列中确定给定元素是否存在          |
| merge()                    | 归并两个有序序列                  |
| inplace_merge()            | 归并两个接续的有序序列               |
| includes()                 | 一序列为另一序列的子序列时为真           |
| set_union()                | 构造两个集合的有序并集               |
| set_intersection()         | 构造两个集合的有序交集               |
| set_difference()           | 构造两个集合的有序差集               |
| set_symmetric_difference() | 构造两个集合的有序对称差集（并-交）        |
| push_heap()                | 向堆中加入元素                   |
| pop_heap()                 | 从堆中弹出元素                   |
| make_heap()                | 从序列构造堆                    |
| sort_heap()                | 给堆排序                      |
| min()                      | 两个值中较小的                   |
| max()                      | 两个值中较大的                   |
| min_element()              | 序列中的最小元素                  |
| max_element()              | 序列中的最大元素                  |
| lexicographical_compare()  | 两个序列按字典序的第一个在前            |
| next_permutation()         | 按字典序的下一个排列                |
| prev_permutation()         | 按字典序的前一个排列                |

#### 数值算法

对容器内容进行数值计算。

| **操作**              | 作用                                       |
| ------------------- | ---------------------------------------- |
| accumulate          | iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上 |
| partial_sum         | 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。 |
| inner_product       | 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。 |
| adjacent_difference | 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 |

由于stl算法十分丰富，上述所列出来的只是其中的一部分。

STL通过算法的泛型化来使算法独立于所处理的数据结构之外。关键在于，把操作对象的类型加以抽象化，把操作对象的标示法和区间目标的移动行为抽象化。下面以find函数为例来解释如何实现泛型化。

template &lt;class Iterator, class T&gt;
Iterator find(Iterator begin, Iterator end, const T& value)

\{

        while (begin != end && *begin != value)
    
            ++begin;
        
        return begin;
\}

在此用Iterator代替实际源码中出现的迭代器类型。如上所述，实际迭代器分为5类，每一个STL算法的声明都表现出它所需要的最低程度的迭代器类型。通过这样的抽象化处理，使得算法能够独立于实际的容器和数据类型而存在。如上find函数，只要提供两个迭代器和一个给定值，便可实现查找操作，而与实际容器是什么，给定值时什么类型完全无关。
